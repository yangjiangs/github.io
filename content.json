{"meta":{"title":"yangjiang","subtitle":null,"description":"海迷、爱运动、爱交友、爱旅行、喜欢接触新鲜事物、迎接新的挑战，更爱游离于错综复杂的编码与逻辑中","author":"杨 江","url":"http://yangchaojiang.cn"},"pages":[{"title":"","date":"2017-06-04T11:38:29.762Z","updated":"2017-06-03T20:13:22.000Z","comments":true,"path":"README.html","permalink":"http://yangchaojiang.cn/README.html","excerpt":"","text":"yangjiangs.github.io"}],"posts":[{"title":"基于exoPlayer 自定义播放器","slug":"jPlayer-blog","date":"2017-09-05T03:42:05.000Z","updated":"2017-09-05T15:19:52.128Z","comments":true,"path":"2017/09/05/jPlayer-blog/","link":"","permalink":"http://yangchaojiang.cn/2017/09/05/jPlayer-blog/","excerpt":"基于exoPlayer 自定义播放器 Jplayer支持功能： 1 ExoUserPlayer 基本播放 2 GestureVideoPlayer 增加手势 亮度，音量，快进，等手势 3 ManualPlayer 默认手动播放，增加默认图 5 增加广告视频预览切换 6 增加视频清晰度切换 7 增加缓存视频功能 8 支持自定义各种数据源加载 Okttp,Rtmp, 缓存，Cronet等协议, 9 支持列表播放视频 10 支持多种文件类型，MP4，M4A，WebM，Matroska，Ogg，WAV，MP3，MPEG-TS，MPEG-PS，FLV，ADTS (AAC)，Flac，M3U8 等 11 支持网络类型 提示是否播放","text":"基于exoPlayer 自定义播放器 Jplayer支持功能： 1 ExoUserPlayer 基本播放 2 GestureVideoPlayer 增加手势 亮度，音量，快进，等手势 3 ManualPlayer 默认手动播放，增加默认图 5 增加广告视频预览切换 6 增加视频清晰度切换 7 增加缓存视频功能 8 支持自定义各种数据源加载 Okttp,Rtmp, 缓存，Cronet等协议, 9 支持列表播放视频 10 支持多种文件类型，MP4，M4A，WebM，Matroska，Ogg，WAV，MP3，MPEG-TS，MPEG-PS，FLV，ADTS (AAC)，Flac，M3U8 等 11 支持网络类型 提示是否播放 预览 显示有点卡，帧数低，实际很流畅 一.引用类库 123456789 repositories &#123; jcenter() maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125; dependencies &#123; compile &apos;com.ycjiang:VideoPlayModule:1.4.8&apos;&#125; 二.控件属性 1.控件属性引用123456789101112131415161718&lt;chuangyuan.ycj.videolibrary.widget.VideoPlayerView android:id=&quot;@+id/exo_play_context_id&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/transparent&quot; app:resize_mode=&quot;fit&quot; app:show_timeout=&quot;3000&quot; app:controller_layout_id=&quot;@layout/simple_exo_playback_control_view&quot; app:player_layout_id=&quot;@layout/simple_exo_view&quot; app:surface_type=&quot;texture_view&quot; app:use_artwork=&quot;true&quot; app:paddingEnd=&quot;0dp&quot; app:paddingStart=&quot;0dp&quot; app:fastforward_increment=&quot;0&quot; app:rewind_increment=&quot;0&quot; app:user_watermark=&quot;@mipmap/watermark_big&quot; app:player_list=&quot;true&quot; app:use_controller=&quot;true&quot; /&gt; 2.属性说明 player_layout_id 播放器布局， //必选 player_layout_id 目前支持指定布局simple_exo_playback_control_view 后续版本，开放自定义使用这自定义 controller_layout_id 控制器布局` //必选 controller_layout_id 支持自定义布局 surface_type 视频渲染类型 //texture_view 和surface_view //枚举类型。默认surface_view 列表播放只能选择texture_view 不能选择surface_view，详情页面播放推荐surface_view use_controller 是否用户控制控制器 布尔类型 resize_mode 视频缩放渲染显示方式一共4种 //可选 美剧类型 1.fit //正常模式 2.fixed_width //保持的是视频宽度，拉伸视频高度 3.fixed_height //保持的是视频高度，拉伸视频宽度 4.fill //全屏模式，拉伸视频宽高 default_artwork 占位图 //可选 占位图 注意在控制布局后下面 show_timeout 控制布局隐藏时间 默认值为3秒 //可选 paddingEnd，paddingStart 设置边距 默认值为0 //可选 fastforward_increment 设置快进增量,以毫秒为单位。 //可选 rewind_increment 设置快退增量,以毫秒为单位。 //可选 user_watermark 水印图片 默认在右上角 //可选 player_list 是否指定列表播放 //可选 默认 false true 列表播放 3.修改网络对话框提示文字内容 app.strings.xml &lt;string name=&quot;exo_play_reminder&quot;&gt;您当前网络不是wifi，是否继续观看视频&lt;/string&gt; &lt;string name=&quot;exo_play_wifi_hint_no&quot;&gt;提示&lt;/string&gt; 4.在功能清单声明 AndroidManifest.xml 在activity节点 加上“android:configChanges=”orientation|keyboardHidden|screenSize”” 如下实例： &lt;activity android:name=&quot;chuangyuan.ycj.yjplay.MainListActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:screenOrientation=&quot;portrait&quot;&gt; 3.JAVA 代码 1 播放控制类 1.ExoUserPlayer 基本播放父类，实现基本播放,设置setPlayUri();会自动加载播放 2.GestureVideoPlayer 具有手势操作播放（调节亮度和视频进度，和音量）会自动加载播放 2.ManualPlayer 点击开始按钮播放,具有手势功能，和列表播放 2 播放//实例化播放控制类 ManualPlayer exoPlayerManager = new ManualPlayer(this,R.id.exo_play_context_id); //自定义你的数据源，后面详细介绍如何自定义数据源类 // ManualPlayer exoPlayerManager = new ManualPlayer(this,R.id.exo_play_context_id,new DataSource(this)); //加载m3u8 exoPlayerManager.setPlayUri(&quot;http://dlhls.cdn.zhanqi.tv/zqlive/35180_KUDhx.m3u8&quot;); //加载ts.文件 exoPlayerManager.setPlayUri(&quot;http://185.73.239.15:25461/live/1/1/924.ts&quot;); //播放本地视频 // exoPlayerManager.setPlayUri(&quot;/storage/emulated/0/DCIM/Camera/VID_20170717_011150.mp4&quot;); //下面开启多线路播放 // exoPlayerManager.setShowVideoSwitch(true); //开启切换按钮，默认关闭 //String [] test={&quot;http://120.25.246.21/vrMobile/travelVideo/zhejiang_xuanchuanpian.mp4&quot;,&quot;http://120.25.246.21/vrMobile/travelVideo/zhejiang_xuanchuanpian.mp4&quot;,&quot;http://120.25.246.21/vrMobile/travelVideo/zhejiang_xuanchuanpian.mp4&quot;}; // String[] name={&quot;超清&quot;,&quot;高清&quot;,&quot;标清&quot;}; //exoPlayerManager.setPlaySwitchUri(test,name); //添加水印图片 // exoPlayerManager.setExoPlayWatermarkImg(); 1.实例化播放控制类 ManualPlayer exoPlayerManager = new ManualPlayer(this,R.id.exo_play_context_id); ManualPlayer exoPlayerManager = new ManualPlayer(this,videoPlayerView); 2.自定义你的数据源，后面详细介绍如何自定义数据源类 ManualPlayer exoPlayerManager = new ManualPlayer(this,R.id.exo_play_context_id,new DataSource(this)); ManualPlayer exoPlayerManager = new ManualPlayer(this,videoPlayerView,new DataSource(this)); 3.设置视频标题 exoPlayerManager.setTitle(&quot;视频标题&quot;); 4.添加水印图片 exoPlayerManager.setExoPlayWatermarkImg(R.mipmap.watermark_big); 5.设置开始播放进度 exoPlayerManager.setPosition(1000) 6.设置视频路径 exoPlayerManager.setPlayUri(&quot;http://dlhls.cdn.zhanqi.tv/zqlive/35180_KUDhx.m3u8&quot;); exoPlayerManager.setPlayUri(Uri.parse(&quot;http://dlhls.cdn.zhanqi.tv/zqlive/35180_KUDhx.m3u8&quot;)); exoPlayerManager.setPlayUri(Environment.getExternalStorageDirectory().getAbsolutePath()+&quot;/test.h264&quot;); //本地视频 7.设置多线路播放 //开启多线路设置，默认关闭 exoPlayerManager.setShowVideoSwitch(true); //支持List列表 String [] test={&quot;http://120.25.246.21/vrMobile/travelVideo/zhejiang_xuanchuanpian.mp4&quot;, &quot;http://120.25.246.21/vrMobile/travelVideo/zhejiang_xuanchuanpian.mp4&quot;, http://120.25.246.21/vrMobile/travelVideo/zhejiang_xuanchuanpian.mp4&quot;}; String[] name={&quot;超清&quot;,&quot;高清&quot;,&quot;标清&quot;}; exoPlayerManager.setPlaySwitchUri(test,name); 8.设置监听回调VideoInfoListener exoPlayerManager.setVideoInfoListener(new VideoInfoListener() { @Override public void onPlayStart() { //开始播放 } @Override public void onLoadingChanged() { //加载变化 } @Override public void onPlayerError(ExoPlaybackException e) { //加载错误 } @Override public void onPlayEnd() { //播放结束 } @Override public void onBack() { //返回回调 Toast.makeText(MainDetailedActivity.this,&quot;f返回&quot;,Toast.LENGTH_LONG).show(); finish(); } @Override public void onRepeatModeChanged(int repeatMode) { //模式变化 } }); 9.覆写Activity和Fragment周期方法 Override public void onResume() { super.onResume(); Log.d(TAG, &quot;onResume&quot;); exoPlayerManager.onResume(); } @Override public void onPause() { super.onPause(); Log.d(TAG, &quot;onPause&quot;); exoPlayerManager.onPause(); } @Override protected void onDestroy() { exoPlayerManager.onDestroy(); super.onDestroy(); } @Override public void onConfigurationChanged(Configuration newConfig) { exoPlayerManager.onConfigurationChanged(newConfig);//横竖屏切换 super.onConfigurationChanged(newConfig); } @Override public void onBackPressed() {//使用播放返回键监听 exoPlayerManager.onBackPressed(); } 三.列表 1.列表播放，只能使用ManualPlayer,在你的VideoHolder 1在列表控件使用属性 ”app:controller_layout_id=”@layout/simple_exo_playback＿list_view”“ //提供默列表控制布局 2.player_list=”true” 设置为true 开启列表模式 3.demo: public class VideoAdapter extends RecyclerView.Adapter&lt;VideoAdapter.VideoViewHolder&gt; { private Context mContext; private List&lt;String&gt; mVideoList; public VideoAdapter(Context context, List&lt;String&gt; videoList) { mContext = context; mVideoList = videoList; } @Override public int getItemCount() { return mVideoList.size(); } @Override public VideoViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View itemView = LayoutInflater.from(mContext).inflate(R.layout.item_video1, parent, false); return new VideoViewHolder(itemView); } @Override public void onBindViewHolder(VideoViewHolder holder, int position) { String video = mVideoList.get(position); holder.bindData(video); } public class VideoViewHolder extends RecyclerView.ViewHolder { ManualPlayer userPlayer; VideoPlayerView playerView; public VideoViewHolder(View itemView) { super(itemView); //初始化控件 playerView = (VideoPlayerView) itemView.findViewById(R.id.item_exo_player_view); userPlayer = new ManualPlayer((Activity) mContext, playerView); } /** *绑定数据源 ***/ public void bindData(String videoBean) { userPlayer.setTitle(&quot;&quot; + getAdapterPosition()); userPlayer.setPlayUri(videoBean); Glide.with(mContext) .load(&quot;http://i3.letvimg.com/lc08_yunzhuanma/201707/29/20/49/3280a525bef381311b374579f360e80a_v2_MTMxODYyNjMw/thumb/2_960_540.jpg&quot;) .into(playerView.getPreviewImage()); } } 2.列表播放周期方法 列表在Activity或者Fragment 实现相应周期方法 protected void onPause() { super.onPause(); VideoPlayerManager.getInstance().onPause(); } @Override protected void onResume() { super.onResume(); VideoPlayerManager.getInstance().onResume(); } @Override protected void onDestroy() { super.onDestroy(); VideoPlayerManager.getInstance().onDestroy(); } @Override public void onBackPressed() { //返回监听类 if (!VideoPlayerManager.getInstance().onBackPressed()){ finish(); } } 四.数据源工厂类1.默认数据源 缓存 : CacheDataSinkFactory,CacheDataSourceFactory http : DefaultDataSourceFactory,DefaultHttpDataSourceFactory Priority : PriorityDataSourceFactory 2 自定义数据源引用compile &apos;com.google.android.exoplayer:extension-okhttp:r2.5.1&apos; compile &apos;com.google.android.exoplayer:extension-rtmp:r2.5.1&apos; 3.自定义数据源工厂类: 实现接口 DataSourceListener 然后在getDataSourceFactory方法里 自定义 数据源 在你使用播放控件时中实例化类 exoPlayerManager = new GestureVideoPlayer(this,videoPlayerView,new DataSource(this)); exoPlayerManager = new GestureVideoPlayer(this,(R.id.exo_play_context_id,new DataSource(this)); demo代码: public class DataSource implements DataSourceListener { public static final String TAG = &quot;DataSource&quot;; private Context context; public DataSource (Context context){ this.context=context; } @Override public com.google.android.exoplayer2.upstream.DataSource.Factory getDataSourceFactory() { OkHttpClient okHttpClient = new OkHttpClient(); OkHttpDataSourceFactory OkHttpDataSourceFactory= new OkHttpDataSourceFactory(okHttpClient, Util.getUserAgent(context, context.getApplicationContext().getPackageName()),new DefaultBandwidthMeter() ); //使用OkHttpClient 数据源工厂 //return OkHttpDataSourceFactory; ; //默认数据源工厂 // return new JDefaultDataSourceFactory(context); // Rtmp数据源工厂 对 Rtmp 协议支持 // return new RtmpDataSourceFactory(); //缓存使用和组合使用 LeastRecentlyUsedCacheEvictor evictor = new LeastRecentlyUsedCacheEvictor(1000000000); SimpleCache simpleCache = new SimpleCache(new File(context.getCacheDir(), &quot;media&quot;), evictor); //缓存数据源使用，内部使用DefaultDataSourceFactory数据源工厂类 // return new CacheDataSinkFactory(simpleCache,10000); // 配合okHttp数据源工厂类 return new CacheDataSourceFactory(simpleCache, OkHttpDataSourceFactory); //使用配合默认数据源红工厂类 // return new CacheDataSourceFactory(simpleCache, new JDefaultDataSourceFactory(context)); //使用提供缓存数据源工厂类 // return new CacheDataSourceFactory(context,1000,1000); } } 五.自定义控制布局 1.使用自定义控制布局 app:controller_layout_id=”@layout/simple_exo_playback_control_view” 详细看 demo app:controller_layout_id 指向您的布局名称 2.注意自定义控制布局事项 不能改变控件类型，可以改变控件的样式，位置，属性等 项目地址－戳我","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yangchaojiang.cn/tags/Android/"},{"name":"Video","slug":"Video","permalink":"http://yangchaojiang.cn/tags/Video/"},{"name":"ListVideo","slug":"ListVideo","permalink":"http://yangchaojiang.cn/tags/ListVideo/"}]},{"title":"新版Bintray-极简上传Library到JCenter，可上传自定义maven仓库","slug":"bintray-release-blog","date":"2017-08-26T00:55:07.000Z","updated":"2017-08-28T07:56:37.616Z","comments":true,"path":"2017/08/26/bintray-release-blog/","link":"","permalink":"http://yangchaojiang.cn/2017/08/26/bintray-release-blog/","excerpt":"背景最近得闲 将封装的开源项目上传到JCenter上，方便供大家使用，但是突然发现Bintray网站更新变化很大，以前老方法上传，过于复杂，代码量也很多，每次编写新库上传，复制代码心累，大家都懂。于是百度,有没有更简便上传方式,我在网上网上很多博客讲解的 Bintray-极简上传Library到JCenter,发现对自定义maven仓库名配置。很多博客文章里没有说明，这一篇文章是讲解如何上传自定义maven仓库下。","text":"背景最近得闲 将封装的开源项目上传到JCenter上，方便供大家使用，但是突然发现Bintray网站更新变化很大，以前老方法上传，过于复杂，代码量也很多，每次编写新库上传，复制代码心累，大家都懂。于是百度,有没有更简便上传方式,我在网上网上很多博客讲解的 Bintray-极简上传Library到JCenter,发现对自定义maven仓库名配置。很多博客文章里没有说明，这一篇文章是讲解如何上传自定义maven仓库下。 开始我们的上传之路！ 注册注册是踩坑的第一步，很多博客或者网站都是直接推荐去官网首页注册： 绝对不要去这里注册 注意：千万别点这里注册，这里现在默认注册的是组织，并不是个人 我就是这一步走错了被这一步坑了，导致一天都没将开源项目提上去 重要的事情说三遍： 个人正确的注册地址:https://bintray.com/signup/oss 个人正确的注册地址:https://bintray.com/signup/oss 个人正确的注册地址:https://bintray.com/signup/oss 后边注册的步骤就很简单了，有github或者google账户的同学直接登录就行了，如果要注册需要注意邮箱不能是国内的邮箱 获取key和user 创建maven仓库 注意：创建的maven仓库类型都写成maven,仓库名称 任意名字，后面配置信息会用到仓库名称 极简上传查看了网上的很多上传方法都很复杂，也都亲自实践过，给大家介绍最简单的一种，其他复杂的直接忽略了，因为也不是什么很高深的东西，只要能到达目的就行了！ jecenter-Jecenter上传开源库有兴趣的同学可以去看看源码 前提是你已经将需要开源的项目独立成moudel，并且已经是com.android.library 1.根目录下的build.gradle中加入上传开源库的依赖：1classpath &apos;com.novoda:bintray-release:0.5.0&apos; 2.library的moudel中加入 apply1apply plugin: &apos;com.novoda.bintray-release&apos; 注意：bintray-releas的版本 依赖，对应你项目使用 Gradle 版本 1.bintray-releas version 0.5.0 对应 Gradle 是 version 3.4+ (包括3.4) 2.bintray-releas version 0.4.0 对应 Gradle 是 version 3.3+ (包括3.3) 3.bintray-releas version 0.3.4 对应 Gradle 是 version 1.3.0+(包括1.3) 如果版本不对应 就有可能项目库上传失败 红线内没有版本号信息 3.如果你开源库中有中文注释在moudel的build.gradle加入格式123456789101112allprojects &#123; repositories &#123; jcenter() &#125; //加上这些 tasks.withType(Javadoc) &#123; options&#123; encoding &quot;UTF-8&quot; charSet &apos;UTF-8&apos; links &quot;http://docs.oracle.com/javase/7/docs/api&quot; &#125; &#125;&#125; 4.忽略错误信息：moudel的build.gradle1234567android &#123;************ lintOptions &#123; abortOnError false &#125;&#125; 5.配置基本信息12345678910publish &#123; repoName=&quot;ycjiang&quot;//仓库名 userOrg = &apos;ycjiang&apos; //bintray注册的用户名 groupId = &apos;com.ycjiang&apos; //compile引用时的第1部分groupId artifactId = &apos;QiniuModule&apos; //compile引用时的第2部分项目名 publishVersion = &apos;1.0.1&apos; //compile引用时的第3部分版本号 desc = &apos;This is a rxbus same of eventbus extend library &apos;//d项目描述 repoName=&quot;ycjiang&quot; //你的仓库名称，没有填写默认仓库是maven//这也是很多人上传仓库不对名问题最多情况， website = &apos;&apos; //github 托管地址&#125; 6.仓库名重要性 repoName 如果没有填写，上传的库默认仓库是maven，这个:bintray-release上传也是最多原因. 很多用户的压根没有这个仓库, 然后百度，发现,Bintray需要手动创建仓库是maven。 既然手动创建仓库，为什么仓库名为何自己用定义仓库名， Bintray是可以新建仓库.repoName 这个属性就可以自己项目上传到自己定义仓库下。 通过配置我们最后的依赖地址=第一部分+第二部分+第三部分； 1compile &apos;com.ycjiang:QiniuModule:1.0.1&apos; 版本更新只需要修改publishVersion 即可； 7.切换到AndroidStudio temrinal或者cmd后台中运行： 配置基本信息没有填写 bintrayUser和bintrayKey 使用下面 windows 系统：1gradlew clean build bintrayUpload -PbintrayUser=BINTRAY_USERNAME -PbintrayKey=BINTRAY_KEY -PdryRun=false os x系统中如果出现拒绝该命令./gradlew: Permission denied，可以先运行 chmod +x gradlew再运行该命令；第一次运行需要下载文件需要稍微等待。 1./gradlew clean build bintrayUpload -PbintrayUser=BINTRAY_USERNAME -PbintrayKey=BINTRAY_KEY -PdryRun=false 其中BINTRAY_USERNAME换成bintray注册的用户名，BINTRAY_KEY换成自己的APIKEY 8.观察后台输出： 回车执行命令，看到BUILD SUCCESS即上传成功 9.发布项目到公用Jecenter中回到主页的你上传仓库中，点击进入，如果你上次成功即可看见你刚刚上次的开源项目 点击进入项目中，然后点击add加入commit就行了，一般需要等待审核通过，一般5-6小时 commit内容推荐是同英文，不要中文 10.依赖使用在审核通过前可以通过配置自己私有仓地址使用 在更目录下build.gradle配置地址 123456allprojects &#123; repositories &#123; jcenter() maven &#123; url &quot;https://jitpack.io&quot; &#125; //审核后可使用 maven &#123; url &quot;https://dl.bintray.com/ycjiang/maven&quot; &#125;//审核前可使用 &#125; 项目中加入依赖： 1compile &apos;com.ycjiang:QiniuModule:1.0.1&apos; 好了，现在你就可以在你项目中依赖你的开源库了，就是这么简单！ 项目在第一次上传的过程中可以参考我的工程仿照配置 传送门-开源项目-AaComponents-戳我","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yangchaojiang.cn/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://yangchaojiang.cn/tags/Kotlin/"},{"name":"Gradle","slug":"Gradle","permalink":"http://yangchaojiang.cn/tags/Gradle/"}]},{"title":"快速上手Kotlin14招 第二期","slug":"kotlin-blog-2","date":"2017-07-14T00:55:07.000Z","updated":"2017-07-14T04:56:51.307Z","comments":true,"path":"2017/07/14/kotlin-blog-2/","link":"","permalink":"http://yangchaojiang.cn/2017/07/14/kotlin-blog-2/","excerpt":"这篇文章主要，接着快速上手Kotlin11招 第一期的补充","text":"这篇文章主要，接着快速上手Kotlin11招 第一期的补充 1. 如何println 输出 Java println 输出 12System.out.print(&quot;Amit Shekhar&quot;);System.out.println(&quot;Amit Shekhar&quot;); 基本等价的 Kotlin 12print(&quot;Amit Shekhar&quot;)println(&quot;Amit Shekhar&quot;) 2. 如何取到字符长度 Java 取到字符长度 123if(text != null)&#123; int length = text.length();&#125; Kotlin 取到字符长度 形式不同java 123text?.let &#123; val length = text.length&#125; 3. 如何拼接字符串 Java 拼接字符用“+”链接字符，麻烦容易出错，反复双引号，代码很糟糕 123String firstName = &quot;Amit&quot;;String lastName = &quot;Shekhar&quot;;String message = &quot;My name is: &quot; + firstName + &quot; &quot; + lastName; 等价 Kotlin 就整洁很多 “$变量名” 或者${变量名} 添加需要插入字符位置 1234val firstName = &quot;Amit&quot;val lastName = &quot;Shekhar&quot;val message = &quot;My name is: $firstName $lastName&quot;val message = &quot;My name is: $&#123;firstName&#125; $&#123;lastName&#125;&quot; 4. 如何类之间转换 Java 需要当前类实例 使用 关键字 “instanceof” 是否属于需要转换类 然后强制转换该类 123if(object instanceof Car)&#123;&#125;Car car = (Car) object; Kotlin 等价 是 关键 “is” 是否属于需要转换 然后用 关键字 “as” 转换类 123if (object is Car) &#123;&#125;var car = object as Car 5. 如何数字判断在范围内 Java 1if(score &gt;= 0 &amp;&amp; score &lt;= 300 )&#123;&#125; Kotlin 同等 使用关键字 “in” 起始值..结束值 1if (score in 0..300) &#123; &#125; 6. 如何使用分支条件 Java 使用 “switch” 关键字 123456789101112131415161718192021222324int score = // some score;String grade;switch (score) &#123; case 10: case 9: grade = &quot;Excellent&quot;; break; case 8: case 7: case 6: grade = &quot;Good&quot;; break; case 5: case 4: grade = &quot;Ok&quot;; break; case 3: case 2: case 1: grade = &quot;Fail&quot;; break; default: grade = &quot;Fail&quot;; &#125; Kotlin 使用 when 很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔： 12345678var score = // some scorevar grade = when (score) &#123; 9, 10 -&gt; &quot;Excellent&quot; in 6..8 -&gt; &quot;Good&quot; 4, 5 -&gt; &quot;Ok&quot; in 1..3 -&gt; &quot;Fail&quot; else -&gt; &quot;Fail&quot;&#125; when语法 7. for 循环差别 Java 12345678910111213for (int i = 1; i &lt;= 10 ; i++) &#123; &#125;for (int i = 1; i &lt; 10 ; i++) &#123; &#125;for (int i = 10; i &gt;= 0 ; i--) &#123; &#125;for (int i = 1; i &lt;= 10 ; i+=2) &#123; &#125;for (int i = 10; i &gt;= 0 ; i-=2) &#123; &#125;for (String item : collection) &#123; &#125;for (Map.Entry&lt;String, String&gt; entry: map.entrySet()) &#123; &#125; Kotlin for 循环可以对任何提供迭代器（iterator）的对象进行遍历 12345678910111213for (i in 1..10) &#123; &#125;for (i in 1 until 10) &#123; &#125;for (i in 10 downTo 0) &#123; &#125;for (i in 1..10 step 2) &#123;&#125;for (i in 10 downTo 1 step 2) &#123;&#125;for (item in collection) &#123;&#125;for ((key, value) in map) &#123;&#125; 8. 集合操作差别 Java 12345678910111213final List&lt;Integer&gt; listOfNumber = Arrays.asList(1, 2, 3, 4);final Map&lt;Integer, String&gt; keyValue = new HashMap&lt;Integer, String&gt;();map.put(1, &quot;Amit&quot;);map.put(2, &quot;Ali&quot;);map.put(3, &quot;Mindorks&quot;);// Java 9final List&lt;Integer&gt; listOfNumber = List.of(1, 2, 3, 4);final Map&lt;Integer, String&gt; keyValue = Map.of(1, &quot;Amit&quot;, 2, &quot;Ali&quot;, 3, &quot;Mindorks&quot;); Kotlin 1234val listOfNumber = listOf(1, 2, 3, 4)val keyValue = mapOf(1 to &quot;Amit&quot;, 2 to &quot;Ali&quot;, 3 to &quot;Mindorks&quot;) 9. forEach 循环变化Java12345678910111213141516// Java 7 and belowfor (Car car : cars) &#123; System.out.println(car.speed);&#125;// Java 8+cars.forEach(car -&gt; System.out.println(car.speed));// Java 7 and belowfor (Car car : cars) &#123; if(car.speed &gt; 100) &#123; System.out.println(car.speed); &#125;&#125;// Java 8+cars.stream().filter(car -&gt; car.speed &gt; 100).forEach(car -&gt; System.out.println(car.speed)); Kotlin for语法12345cars.forEach &#123; println(it.speed)&#125;cars.filter &#123; it.speed &gt; 100 &#125; .forEach &#123; println(it.speed)&#125; 10. 有返回值类型方法区别 Java 方法修改 void 需要返回 类型 1234int getScore() &#123; // logic here return score;&#125; Kotlin 不需要修改 方法结构 使用 “:” 需要返回类型 12345678fun getScore(): Int &#123; // logic here return score&#125;// as a single-expression functionfun getScore(): Int = score 11. 实体类区别 Java 跟常规类没有差别，实体类代码量很多 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Developer &#123; private String name; private int age; public Developer(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Developer developer = (Developer) o; if (age != developer.age) return false; return name != null ? name.equals(developer.name) : developer.name == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; &#125; @Override public String toString() &#123; return &quot;Developer&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, age=&quot; + age + &apos;&#125;&apos;; &#125;&#125; Kotlin 提供了 “data”关键字 数据实体类 大大降低代码量 1data class Developer(var name: String, var age: Int) 12. 如何使使用单例模式 Java 当中： （建议使用） 123456789101112131415161718192021222324/** * Created by yangc on 2017/6/9. * E-Mail:yangchaojiang@outlook.com * Deprecated: 定义一个私有的内部类，在第一次用这个嵌套类时，会创建一个实例。 * 而类型为SingletonHolder的类，只有在Singleton.getInstance()中调用， * 由于私有的属性，他人无法使用SingleHolder，不 * 调用Singleton.getInstance()就不会创建实例。 * 优点：达到了lazy loading的效果，即按需创建实例 */public class UserSingle &#123; static UserSingle getInstance() &#123; return Holder.userSingle; &#125; // 定义一个私有的构造方法 private UserSingle() &#123; &#125; private static class Holder &#123; static final UserSingle userSingle = new UserSingle(); &#125;&#125; Kotlin 中： 关键字 object 这个类属于单例 12345678910111213141516 class UserSingle private constructor() &#123; companion object &#123; @JvmStatic //java 访问 fun getInstance(): UserSingle &#123; return Holder.instance &#125; &#125; private object Holder &#123; val instance = UserSingle() &#125;&#125; 单例模式 生对象更多的用途是用来创建一个单例类。 如果只是简单的写，直接用伴生对象返回一个 val 修饰的外部类对象就可以了， 但是更多的时候我们希望在类被调用的时候才去初始化他的对象。 以下代码将线程安全问题交给虚拟机在静态内部类加载时处理，是一种推荐的写 13. 如何使使用回调函数 Java 当中： 123456789101112textView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125; &#125;); textView.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; return false; &#125; &#125;); Kotlin 中： 12345678910111213 //不使用参数 返回void btnWrite.setOnClickListener &#123; fileWrite() &#125; //使用参数 返回void btnWrite.setOnClickListener &#123; view-&gt; fileWrite(c.getid() &#125; //使用参数 返回void btnWrite.setOnClickListener &#123; view-&gt; fileWrite(c.getid() true&#125; 在 kotlin 使用lambda 表达式，不用new 匿名内部类进行回调 {}括号中，直接添加代码 14. 如何使用 findViewById 在java中 或者使用著名butterknife 注解控件 12345678910111213 TextView textView; .... textView = (TextView) findViewById(R.id.textView); ..... //或者 @BindView(R.id.textView) TextView textView; @BindView(R.id.textView) TextView textView; @BindView(R.id.textView) TextView textView; .... java在复杂布局占用代码行数通常是。。。这个说出来 在kotlin 中 1234567lateinit var textView :TextViewlateinit var textView2 :TextView...//实例化时 textView=findViewById(R.id.textView) as TextView textView2=findViewById(R.id.textView2) as TextView 好像没什么，只是转换形式的变了，实现还是一样。别急kotlin 提供不用findViewVById 就可以得到控件实例，进行赋值等操作共两步骤 1。你的app 的build.gradle 文件里加入 代码如下： 1apply plugin: &apos;kotlin-android-extensions&apos; 2 在你使用acitvity 或者fragment 等类 添加引用 import;代码如下：12345678910111213import kotlinx.android.synthetic.main.activity_main.*class MainActivity: AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) textView.setText(&quot;赋值&quot;) textView.text=&quot;赋值&quot;]&#125; 直接控件id名称实例的操作 不需要在 findViewBYid 实例化和声明“kotlinx.android.synthetic.main”固定 的 后面是就是activity语对应布局名称 在复杂布局的也不用写一堆声明控件和findViewById 等无脑代码","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yangchaojiang.cn/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://yangchaojiang.cn/tags/Kotlin/"}]},{"title":"Android ImageView 正确使用姿势","slug":"android-imageview-blog","date":"2017-06-23T06:13:55.000Z","updated":"2017-06-23T07:50:22.431Z","comments":true,"path":"2017/06/23/android-imageview-blog/","link":"","permalink":"http://yangchaojiang.cn/2017/06/23/android-imageview-blog/","excerpt":"Android ImageView 正确使用姿势本文主要介绍了ImageView的相关重要方法，从源码角度剖析了一些容易令人混淆或百思不得其解的问题。","text":"Android ImageView 正确使用姿势本文主要介绍了ImageView的相关重要方法，从源码角度剖析了一些容易令人混淆或百思不得其解的问题。 一、正确合理使用ImageView 的src 和background src ：为ImageView 原图内容，存放原图大小，不会被拉伸； background：为Imageview的背景，会根据ImageView给定的长宽进行拉伸； 在ImageView中，可以同时设置src和background属性（为了减少绘制，可以根据使用场景来设置相应属性）； 由于src中存放的是原图大小，如果需要对其缩放，就需要使用android:scaleTyle这个属性（scaleType 只对src属性有效），另外还可以对background设置透明度。 二、正确设置Imageview的透明度设置ImageView的透明度有啥正确不正确的，如直接就mImageView.setAlpha(100)，不就行了吗？（答案是不确定，后续分析） ImageView 设置透明度主要有以下三种方法： setAlpha(@FloatRange(from=0.0, to=1.0) float alpha) （View提供） setAlpha(int alpha) （已经标记为@Deprecated） setImageAlpha(int alpha) （API&gt;=16） 其中，setImageAlpha内部调用setAlpha(int alpha)方法，查看API可知，setAlpha 主要是针对image而言，使用setImageView，一方面在命名上更为贴切与View中的setAlpha方法区分，同时做好兼容性，目前只能使用在API&gt;=16的场景。 另外， 像Drawable 和Paint中的都是调用setAlpha(int alpha) 在本节前就提了一个问题：直接使用mImageView.setAlpha(100)，来设置ImageView的透明度是否正确？ 正确答案是： android:src在设置ImageView的setAlpha(int alpha)时，起作用； android:background在设置ImageView的setAlpha(int alpha)时，不起作用。 为什么呢？ 在前面介绍中，已经指出ImageView中的setAlpha(int alpha)方法是针对image有效的，想弄清就直接看源码： （1）setAlpha(int alpha)方法 图1 ImageView 的setAlpha() （2）通过applyColorMod方法可知，ImageView.setAlpha(int alpha)方法，是通过Drawable.setAlpha(int alpha)实现的 图2 ImageView的applyColorMod() 那么mDrawable 是怎样得到的了： setImageDrawable(Drawable d) 中调用 updateDrawable(Drawable d)，而mDrawable 正是在updateDrawable(Drawable d)中赋值的： 图4 ImageView的updateDrawable()方法 现在知道为什么有时候ImageView.setAlpha(int alpha)没起作用了吧。 （3）在applyColorMod()中为什么使用Drawable.mutate()方法 直接引用Drawable.mutate()的JavaDoc： Make this drawable mutable. This operation cannot be reversed. A mutable drawable is guaranteed to not share its state with any other drawable. This is especially useful when you need to modify properties of drawables loaded from resources. By default, all drawables instances loaded from the same resource share a common state; if you modify the state of one instance, all the other instances will receive the same modification.Calling this method on a mutable Drawable will have no effect. 上述解释的很清楚，一个drawable如果使用了mutate()方法，那么对这个drawable属性（包括设置drawable的透明度）修改将不会共享。 12mImageView.setBackgroundDrawable(mDrawable);mImageView.getBackground().setAlpha(100); 上述代码有问题吗？ “肯定没有额，通过这种方式透明度没有问题额，亲试可用”。如果你所使用的mDrawable是图片资源（ColorDrawable 中使用了mutate方法），而且多处使用，你就会发现，其他地方透明度也变了。 上述代码正确写法： 12mImageView.setBackgroundDrawable(mDrawable.mutate());mImageView.getBackground().setAlpha(100); （4）总结通过上面的分析可知，设置ImageView的透明度，坑还是相当多的，目前来看使用View提供的setAlpha(float alpha)更好。 三、正确设置ImageView的前景（foreground）有时候设计需要在ImageView 上面覆盖一层（如灰色），面对这样的需求时，要区分是静态的ImageView还是异步的ImageView （使用后台回包数据）。 （1）静态ImageView （此场景基本很少，设计切图即可）合理使用src （前景）和background（背景）就可以实现 （2）异步ImageView此就需要使用ImageView的前景（View 提供了一个setForeground(Drawable foreground)） 图5 View的setForeground()方法图 6 view的构造函数中mForegroundInfo对象创建 根据上述源码可知，如果ImageView要使用setForeground()方法，必须保证targetSdkVersion&gt;=23。 如果此时要在targetSdkVersion&lt;23情况使用，就必须自己去实现，好在afc框架中ExtendImageView已经考虑到这种情况，已经实现了setForeFround()方法。 四、正确使用ImageView的“android:adjustViewBounds”adjustViewBounds的介绍如下： Set this to true if you want the ImageView to adjust its bounds to preserve the aspect ratio of its drawable. Note:If the application targets API level 17 or lower, adjustViewBounds will allow the drawable to shrink the view bounds, but not grow to fill available measured space in all cases.This is for compatibility with legacy MeasureSpec and RelativeLayout behavior. 设置View的最大高度，单独使用无效，需要与setAdjustViewBounds一起使用；如果想设置图片固定大小，又想保持图片宽高比，需要如下设置： 设置setAdjustViewBounds为true； 设置maxWidth、MaxHeight； 设置设置layout_width和layout_height为wrap_content 五、正确使用ImageView的“android:scaleType”如前所说，ImageView的“android:scaleType”属性是对src才有效的，如下图所示，需要对下面原图进行缩放控制，效果如下： （1）原图 （2）使用ScaleType.CENTER_CORP 设计大大觉得不合理，要是图片整体能下来一点点就好了，查看一遍ScaleType，能到达这样效果的只有FIT_XY，那就试试看 （3）使用ScaleType.FIT_XY 图片确实下移了，但是图却明显的被拉长了 （4）使用ScaleDrawable.CROP_START ScaleDrawable类是afc框架中提供了一个专门处理Drawable scale的类，在ImageView的ScaleType的基础上额外提供了11中裁剪方式： 1234567891011（1）CROP_CENTER（2）CROP_START（3）CROP_END（4）FIT_CENTER（5）FIT_START（6）FIT_END（7）MATCH_WIDTH_TOP（8）MATCH_WIDTH_BOTTOM（9）MATCH_WIDTH_CENTER（10）CENTER（11）CROP_BY_PIVOT （5）XML设置android:scaleType=”fitXY”属性xml中设置scaleType属性 _java代码中设置ScaleDrawable.CROPSTART属性 看到上述代码，有人可能觉得很疑惑，既然在java代码中设置了ScaleDrawable.CROP_START属性，为什么XML中还要设置“android:scaleType=”fitXY”，能否不设置或者设置其他属性。 答案是否定的，如果要保证ScaleDrawable.CROP_START属性设置成功，在xml中一定要设置“android:scaleType=”fitXY”，原因如下： 1）通过ScaleDrawable设置scaleTypesetScaleType()方法 2）在updateDrawMatrix()中更新目的宽高 （dstWidth和dstHeight）updateDrawMatrix()方法 可以看到，如果要ScaleDrawable.CROP_START属性设置起作用，那个getBounds()方法获取一定要准确。 3）通过查看ImageView中的configBounds()方法可知，在dwith和dheight（原图Drawable的宽高）都不为0的情况下，如果要使用vwidth和vheight，则ImageView的ScaleType必须设置为ScaleType.FIT_XYconfigBounds()方法 最后本人能力有限，分析可能不到位或错误的地方，如果发现，请告知谢谢！","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yangchaojiang.cn/tags/Android/"}]},{"title":"快速上手Kotlin11招","slug":"kotlin-blog","date":"2017-06-08T14:08:52.000Z","updated":"2017-07-14T04:56:44.620Z","comments":true,"path":"2017/06/08/kotlin-blog/","link":"","permalink":"http://yangchaojiang.cn/2017/06/08/kotlin-blog/","excerpt":"最近经常会收到一些 “用 Kotlin 怎么写” 的问题，我们已经掌握了一门或者多门语言，那么学 Kotlin 的时候就经常会有类似 “ ‘再见’用日语怎么说？”、“ ‘你好’ 用西班牙语怎么说？” 的问题，所以我决定把一些常用的语法对照列举出来，如果大家熟悉 Java，那么快速上手 Kotlin 会变得非常地容易。","text":"最近经常会收到一些 “用 Kotlin 怎么写” 的问题，我们已经掌握了一门或者多门语言，那么学 Kotlin 的时候就经常会有类似 “ ‘再见’用日语怎么说？”、“ ‘你好’ 用西班牙语怎么说？” 的问题，所以我决定把一些常用的语法对照列举出来，如果大家熟悉 Java，那么快速上手 Kotlin 会变得非常地容易。 这篇文章主要是写给需要快速上手 Kotlin 的 Java 程序员看的，这时候他们关注的是如何 Kotlin 写出类似某些 Java 的写法，所以本文基本不涉及 Kotlin 的高级特性。 1. 如何定义变量 Java 定义变量的写法： 1String string = &quot;Hello&quot;; 基本等价的 Kotlin 定义变量的写法： 1var string: String = &quot;Hello&quot; Java 定义 final 变量的写法： 1final String string = &quot;Hello&quot;; 注意到前面的是一个编译期常量，Kotlin 当中应该这么写： 1const val string: String = &quot;Hello&quot; 同样是 final 变量，Java 这么写： 1final String string = getString(); 注意到，这个不是编译期常量，Kotlin 这么写： 1val string: String = getString() 另外， Kotlin 有类型推导的特性，因此上述变量定义基本上都可以省略掉类型 String。 2. 如何定义函数Java 当中如何定义函数，也就是方法，需要定义到一个类当中： 123public boolean testString(String name)&#123; ...&#125; 等价的 Kotlin 写法： 123fun testString(name: String): Boolean &#123; ...&#125; 注意到返回值的位置放到了参数之后。 3. 如何定义静态变量、方法Java 的静态方法或者变量只需要加一个 static 即可： 123456789public class Singleton&#123; private static Singleton instance = ...; public static Singleton getInstance()&#123; ... return instance; &#125;&#125; 用 Kotlin 直译过来就是： 1234567891011class KotlinSingleton&#123; companion object&#123; private val kotlinSingleton = KotlinSingleton() @JvmStatic fun getInstance() = kotlinSingleton &#125;&#125; 注意 getInstance 的写法。 JvmStatic 这个注解会将 getInstance 这个方法编译成与 Java 的静态方法一样的签名，如果不加这个注解，Java 当中无法像调用 Java 静态方法那样调用这个方法。 另外，对于静态方法、变量的场景，在 Kotlin 当中建议使用包级函数。 4. 如何定义数组Java 的数组非常简单，当然也有些抽象，毕竟是编译期生成的类： 123String[] names = new String[]&#123;&quot;Kyo&quot;, &quot;Ryu&quot;, &quot;Iory&quot;&#125;;String[] emptyStrings = new String[10]; Kotlin 的数组其实更真实一些，看上去更让人容易理解： 123val names: Array&lt;String&gt; = arrayOf(&quot;Kyo&quot;, &quot;Ryu&quot;, &quot;Iory&quot;)val emptyStrings: Array&lt;String?&gt; = arrayOfNulls(10) 注意到，ArrayT 即数组元素的类型。另外，String? 表示可以为 null 的 String 类型。 数组的使用基本一致。需要注意的是，为了避免装箱和拆箱的开销，Kotlin 对基本类型包括 Int、Short、Byte、Long、Float、Double、Char 等基本类型提供了定制版数组类型，写法为 XArray，例如 Int 的定制版数组为 IntArray，如果我们要定义一个整型数组，写法如下： 1val ints = intArrayOf(1, 3, 5) 5. 如何写变长参数Java 的变长参数写法如下： 123void hello(String... names)&#123; ...&#125; Kotlin 的变长参数写法如下： 123fun hello(vararg names: String)&#123;&#125; 6. 如何写三元运算符Java 可以写三元运算符： 1int code = isSuccessfully? 200: 400; 很多人抱怨 Kotlin 为什么没有这个运算符。。。据说是因为 Kotlin 当中 : 使用的场景比 Java 复杂得多，因此如果加上这个三元运算符的话，会给语法解析器带来较多的麻烦，Scala 也是类似的情况。那么这中情况下，我们用 Kotlin 该怎么写呢？ 1int code = if(isSuccessfully) 200 else 400 注意到，if else 这样的语句也是表达式，这一点与 Java 不同。 7. 如何写 main 函数Java 的写法只有一种： 123456class Main&#123; public static void main(String... args)&#123; ... &#125;&#125; 注意到参数可以是变长参数或者数组，这二者都可。 对应 Kotlin，main 函数的写法如下： 1234567891011class KotlinMain&#123; companion object&#123; @JvmStatic fun main(args: Array&lt;String&gt;) &#123; &#125; &#125;&#125; Kotlin 可以有包级函数，因此我们并不需要声明一个类来包装 main 函数： 123fun main(args: Array&lt;String&gt;)&#123; ...&#125; 8. 如何实例化类Java 和 C++ 这样的语言，在构造对象的时候经常需要用到 new 这个关键字，比如： 1Date date = new Date(); Kotlin 构造对象时，不需要 new 这个关键字，所以上述写法等价于： 1val date = Date() 9. 如何写 Getter 和 Setter 方法Java 的 Getter 和 Setter 是一种约定俗称，而不是语法特性，所以定义起来相对自由： 12345678910111213public class GetterAndSetter&#123; private int x = 0; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125;&#125; Kotlin 是有属性的： 12345678class KotlinGetterAndSetter&#123; var x: Int = 0 set(value) &#123; field = value &#125; get() = field&#125; 注意看到，我们为 x 显式定义了 getter 和 setter，field 是 x 背后真正的变量，所以 setter 当中其实就是为 field 赋值，而 getter 则是返回 field。如果你想要对 x 的访问做控制，那么你就可以通过自定义 getter 和 setter 来实现了： 123456789101112131415161718192021class KotlinGetterAndSetter&#123; var x: Int = 0 set(value) &#123; val date = Calendar.getInstance().apply &#123; set(2017, 2, 18) &#125; if(System.currentTimeMillis() &lt; date.timeInMillis)&#123; println(&quot;Cannot be set before 2017.3.18&quot;) &#125;else&#123; field = value &#125; &#125; get()&#123; println(&quot;Get field x: $field&quot;) return field &#125; &#125; 10. 如何延迟初始化成员变量Java 定义的类成员变量如果不初始化，那么基本类型被初始化为其默认值，比如 int 初始化为 0，boolean 初始化为 false，非基本类型的成员则会被初始化为 null。 12345public class Hello&#123; private String name;&#125; 类似的代码在 Kotlin 当中直译为： 12345class Hello&#123; private var name: String? = null&#125; 使用了可空类型，副作用就是后面每次你想要用 name 的时候，都需要判断其是否为 null。如果不使用可控类型，需要加 lateinit 关键字： 12345class Hello&#123; private lateinit var name: String&#125; lateinit 是用来告诉编译器，name 这个变量后续会妥善处置的。 对于 final 的成员变量，Java 要求它们必须在构造方法或者构造块当中对他们进行初始化： 12345public class Hello&#123; private final String name = &quot;Peter&quot;;&#125; 也就是说，如果我要想定义一个可以延迟到一定实际再使用并初始化的 final 变量，这在 Java 中是做不到的。 Kotlin 有办法，使用 lazy 这个 delegate 即可： 123456789class Hello&#123; private val name by lazy&#123; NameProvider.getName() &#125;&#125; 只有使用到 name 这个属性的时候，lazy 后面的 Lambda 才会执行，name 的值才会真正计算出来。 11. 如何获得 class 的实例Java 当中： 12345678910public class Hello&#123; ...&#125;...Class&lt;?&gt; clazz = Hello.class;Hello hello = new Hello();Class&lt;?&gt; clazz2 = hello.getClass(); 前面我们展示了两种获得 class 的途径，一种直接用类名，一种通过类实例。刚刚接触 Kotlin 的时候，获取 Java Class 的方法却是容易让人困惑。 同样效果的 Kotlin 代码看上去确实很奇怪，实际上 Hello::class 拿到的是 Kotlin 的 KClass，这个是 Kotlin 的类型，如果想要拿到 Java 的 Class 实例，那么就需要前面的办法了。 123class Helloval clazz = Hello::class.javaval hello = Hello()val clazz2 = hello.javaClass demo: https://github.com/yangchaojiang/FrameWorkDemo demo 只能在 Android Sudio 3.0 编译的，","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yangchaojiang.cn/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://yangchaojiang.cn/tags/Kotlin/"}]},{"title":"Architecture_Components  leficycle","slug":"leficycle-blog","date":"2017-06-05T02:14:26.000Z","updated":"2017-06-06T10:47:28.000Z","comments":true,"path":"2017/06/05/leficycle-blog/","link":"","permalink":"http://yangchaojiang.cn/2017/06/05/leficycle-blog/","excerpt":"Handling Lifecycles（处理生命周期）在自定义活动和片段实现LifecycleOwner 该android.arch.lifecycle 包提供的类和接口，让您构建生命周期感知 组件-这是可以基于一个活动或片段的当前生命周期自动调整自己的行为组件。 注意：要导adding components to your project。","text":"Handling Lifecycles（处理生命周期）在自定义活动和片段实现LifecycleOwner 该android.arch.lifecycle 包提供的类和接口，让您构建生命周期感知 组件-这是可以基于一个活动或片段的当前生命周期自动调整自己的行为组件。 注意：要导adding components to your project。 大多数在Android框架中定义的应用程序组件都安装到他们的生命周期。这些生命周期是由操作系统或在你的进程中运行的框架代码管理。 他们是核心到Android是如何工作的，你的应用程序必须尊重他们。不这样做可能会触发内存泄漏，甚至应用程序崩溃。 试想一下，我们有一个在屏幕上显示的设备位置的活动。一个常见的实现可能像下面这样： 123456789101112131415161718192021222324252627282930313233class MyLocationListener &#123; public MyLocationListener(Context context, Callback callback) &#123; // ... &#125; void start() &#123; // connect to system location service &#125; void stop() &#123; // disconnect from system location service &#125;&#125;class MyActivity extends AppCompatActivity &#123; private MyLocationListener myLocationListener; public void onCreate(...) &#123; myLocationListener = new MyLocationListener(this, (location) -&gt; &#123; // update UI &#125;); &#125; public void onStart() &#123; super.onStart(); myLocationListener.start(); &#125; public void onStop() &#123; super.onStop(); myLocationListener.stop(); &#125;&#125; 尽管这个样品看起来不错，在一个真正的应用程序，你最终有太多的电话像这样和onStart()和onStop()方法变得非常大。 此外，一些部件不能刚刚开始onStart()。如果我们需要在开始位置的观察者之前检查一些配置？这可能是在某些情况下，活动后检查结束停止 ，这意味着myLocationListener.start()被称为之后 myLocationListener.stop()被调用时，基本上保持连接直到永远。123456789101112131415161718192021222324class MyActivity extends AppCompatActivity &#123; private MyLocationListener myLocationListener; public void onCreate(...) &#123; myLocationListener = new MyLocationListener(this, location -&gt; &#123; // update UI &#125;); &#125; public void onStart() &#123; super.onStart(); Util.checkUserStatus(result -&gt; &#123; // what if this callback is invoked AFTER activity is stopped? if (result) &#123; myLocationListener.start(); &#125; &#125;); &#125; public void onStop() &#123; super.onStop(); myLocationListener.stop(); &#125;&#125; 该android.arch.lifecycle 包提供的类和接口，帮助您解决在弹性和孤立的方式这些问题。 LifecycleLifecycle 是，其保持关于一个组件的生命周期状态的信息（如一个活动或片段），并允许其它的目的，观察该状态的一个类。 Lifecycle 使用两个主要的枚举跟踪其相关组件的生命周期状态。 事件这是从架构和调度的生命周期事件 Lifecycle类。这些事件映射到活动和片段的回调事件。 的组件的当前状态由跟踪 Lifecycle对象。 状态看作图的节点和事件，这些节点之间的边缘。 一个类可以通过添加注解它的方法监控组件的生命周期状态。123456789101112public class MyObserver implements LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) public void onResume() &#123; &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) public void onPause() &#123; &#125;&#125;//实现类调用 MainActivity extends LifecycleActivity 或者 interfaceLifecycleActivity extends AppCompatActivity implements LifecycleRegistryOwneraLifecycleOwner.getLifecycle().addObserver(new MyObserver()); LifecycleOwnerLifecycleOwner是表示该类有一个单一的方法接口 Lifecycle。它有一个方法 getLifecycle()，它必须由类实现。 这类抽象的所有权 Lifecycle从个人类（例如，活动和片段），并允许编写的组件，它可以与他们的工作。 任何自定义应用程序类可以实现 LifecycleOwner 接口。 注：由于架构的组件是处于alpha阶段，Fragment而AppCompatActivity类不能执行它（因为我们不能从一个稳定的组件添加依赖不稳定的API）。 直到 Lifecycle稳定， LifecycleActivity 并 LifecycleFragment 提供了便利类。 在生命周期项目发布后，支持文库片段和活动将实现 LifecycleOwner 接口; LifecycleActivity 并且 LifecycleFragment 将在那个时候被弃用。 此外，请参阅实现LifecycleOwner定制活动和片段。 对于上面的例子，我们可以让我们的MyLocationListener类 LifecycleObserver，然后用我们的初始化 Lifecycle在onCreate。 这允许MyLocationListener类是自给自足的，这意味着它可以在必要的时候做自己的清理工作。1234567891011121314class MyActivity extends LifecycleActivity &#123; private MyLocationListener myLocationListener; public void onCreate(...) &#123; myLocationListener = new MyLocationListener(this, getLifecycle(), location -&gt; &#123; // update UI &#125;); Util.checkUserStatus(result -&gt; &#123; if (result) &#123; myLocationListener.enable(); &#125; &#125;); &#125;&#125; 一个常见的情况是为了避免调用一定的回调，如果 Lifecycle在一个良好的状态，是不是现在。 例如，如果回调的活动状态被保存后运行一个片段事务时，它会引发崩溃，所以我们绝不会想要调用该回调。 为了使这个用例方便， Lifecycle类允许其他对象来查询当前状态。 class MyLocationListener implements LifecycleObserver { private boolean enabled = false; public MyLocationListener(Context context, Lifecycle lifecycle, Callback callback) { ... } @OnLifecycleEvent(Lifecycle.Event.ON_START) void start() { if (enabled) { // connect } } public void enable() { enabled = true; if (lifecycle.getState().isAtLeast(STARTED)) { // connect if not connected } } @OnLifecycleEvent(Lifecycle.Event.ON_STOP) void stop() { // disconnect if connected } } 与此实现，我们LocationListener班是完全生命周期感知; 它可以做自己的初始化和清理，而不由活动进行管理。 如果我们需要使用我们LocationListener的另一项活动或另一个片段中，我们只需要初始化。所有的安装和拆卸操作是由类本身来管理。 可与工作类 Lifecycle被称为 生命周期感知组件。 鼓励提供需要的是Android生命周期工作类图书馆提供生命周期数据的组件，从而使他们的客户可以很容易地集成在客户端无需人工生命周期管理这些类。 LiveData在生命周期的感知部件的一个例子。使用 LiveData连同 ViewModel使得它更容易填充的用户界面与数据，同时尊重Android的生命周期。 Best practices for Lifecycles (对于生命周期的最佳实践) 保持您的UI控制器（活动和碎片）尽可能瘦。他们不应该试图获取自己的数据;而是使用ViewModel来执行此操作，并观察LiveData以将更改反映到视图中试着写数据驱动的用户界面在您的UI控制器的责任是更新视图的数据变化，或通知用户操作回 ViewModel。 尝试编写数据驱动的UI，您的UI控制器的责任是在数据更改时更新视图，或将用户操作通知给ViewModel 将您的数据逻辑放在ViewModell类中。 ViewModel应该用作UI控制器和其他应用程序之间的连接器。请注意， ViewModel不是提取数据（例如，从网络）的责任。相反，ViewModel应该调用相应的组件来执行此操作，然后将结果提供给UI控制器 使用Data Binding来保持视图和UI控制器之间的干净接口。这样可以让您的视图更具声明性，并尽可能减少您在活动和片段中编写的更新代码。如果您更喜欢在Java中执行此操作，请使用像Butter Knife这样的库来避免使用样板代码并进行更好的抽象,分離代碼 您的UI很复杂，请考虑创建一个Presenter类来处理UI修改。这通常是过度的，但可能会使您的UI更容易测试 不要在ViewModel 中引用 View 或Activity context。如果 ViewModel 超过活动（在配置更改的情况下），您的活动将被泄漏，而不是正确的垃圾回收 附录####在自定义活动和片段实现LifecycleOwner任何自定义片段或活性可以变成一个 LifecycleOwner通过实现内置 LifecycleRegistryOwner 接口（而不是延伸 LifecycleFragment 或 LifecycleActivity）。 public class MyFragment extends Fragment implements LifecycleRegistryOwner { LifecycleRegistry lifecycleRegistry = new LifecycleRegistry(this); @Override public LifecycleRegistry getLifecycle() { return lifecycleRegistry; } } ` 如果你有，你想使一个自定义类 LifecycleOwner，你可以使用 LifecycleRegistry 类，但你需要事件转发到这个类。这种转发 ，如果他们执行的片段和活动自动完成 LifecycleRegistryOwner界面","categories":[],"tags":[{"name":"Architecture_Components","slug":"Architecture-Components","permalink":"http://yangchaojiang.cn/tags/Architecture-Components/"},{"name":"leficycle","slug":"leficycle","permalink":"http://yangchaojiang.cn/tags/leficycle/"}]},{"title":"Architecture_Components Room Persistence","slug":"room-blod","date":"2017-06-05T02:00:26.000Z","updated":"2017-06-06T10:58:54.000Z","comments":true,"path":"2017/06/05/room-blod/","link":"","permalink":"http://yangchaojiang.cn/2017/06/05/room-blod/","excerpt":"Room持久性库(Room Persistence Library)Room在SQLite的提供了一个抽象层，允许流利的数据库访问，同时利用的SQLite的全部力量。 注意要导入室到你的Android项目，请参阅将组件添加到您的项目。","text":"Room持久性库(Room Persistence Library)Room在SQLite的提供了一个抽象层，允许流利的数据库访问，同时利用的SQLite的全部力量。 注意要导入室到你的Android项目，请参阅将组件添加到您的项目。 该处理结构化数据的不平凡的数额应用程序可以从本地持久化数据大大受益。最常见的情况是缓存数据的相关部分。这样，当设备无法访问网络，用户可以浏览仍然是内容，而他们处于脱机状态。然后，任何用户发起的内容更改同步到服务器之后，设备重新联机。 核心框架提供了内置的支持与原始SQL的内容合作。虽然这些API是强大的，他们是相当低的水平，需要大量的时间和精力用大量工作： 有原始的SQL查询中没有编译时验证。当你的数据图的变化，你需要手动更新受影响的SQL查询。这个过程可能是耗时且容易出错。 您需要使用大量的样板代码到SQL查询和Java数据对象之间的转换。房间照顾这些问题给你，同时提供了SQLite的一个抽象层。 有Room三个主要部分组成： 数据库:你可以使用这个组件来创建数据库持有者。注释定义实体的名单，以及类的内容定义数据库中的数据访问对象（DAO）的列表。这也是底层的连接的主要接入点。被注解类必须继承抽象类 RoomDatabase。在运行时，你可以通过调用获得它的一个实例Room.databaseBuilder())或 Room.inMemoryDatabaseBuilder())。 实体:该组件代表持有数据库行的类。对于每一个实体，创建一个数据库表来保存的项目。你必须通过引用实体类 entities)的数组Database类。实体的各个领域，除非你将其标注为忽略数据库持久化 @Ignore。 注：实体可以有一个空的构造（如果DAO类可以访问每一个持久化字段）或构造方法的参数包含匹配在实体领域的该类型和名称。房间还可以使用全部或部分的构造，如仅接收一些领域的构造函数。 DAO:此组件表示一个类或接口作为数据访问对象（DAO）。DAO的是房间的主要组成部分，是负责定义访问数据库的方法。被注释与类@Database必须包含具有0参数并返回被注释与类的抽象方法@Dao。当生成在编译时的代码，房创建此类的实现。 注：通过使用DAO类，而不是查询生成器或直接查询访问数据库，也可以分开你的数据库架构的不同组件。此外，DAO中让您轻松为您测试您的应用程序模拟数据库的访问。这些组件，它们与应用程序的其他部分一起的关系，出现在图1： 图1.室架构图下面的代码段包含具有1个实体和1个DAO示例数据库配置： User.java 1234567891011121314@Entitypublic class User &#123; @PrimaryKey private int uid; @ColumnInfo(name = \"first_name\") private String firstName; @ColumnInfo(name = \"last_name\") private String lastName; // Getters and setters are ignored for brevity, // but they're required for Room to work.&#125; UserDao.java 1234567891011121314151617@Daopublic interface UserDao &#123; @Query(\"SELECT * FROM user\") List&lt;User&gt; getAll(); List&lt;User&gt; loadAllByIds(int[] userIds); @Query(\"SELECT * FROM user WHERE first_name LIKE :first AND \" + \"last_name LIKE :last LIMIT 1\") User findByName(String first, String last); @Insert void insertAll(User... users); @Delete void delete(User user);&#125; AppDatabase.java1234@Database(entities = &#123;User.class&#125;, version = 1)public abstract class AppDatabase extends RoomDatabase &#123; public abstract UserDao userDao();&#125; 建立上述文件后，你会得到使用下面的代码创建数据库实例：12AppDatabase db = Room.databaseBuilder(getApplicationContext(), AppDatabase.class, \"database-name\").build(); 注：实例化时，应遵循Singleton设计模式 AppDatabase的对象，因为每个RoomDatabase实例是相当昂贵的，你很少需要访问多个实例。 实体(Entities)当一个类都被注解@Entity，并在被引用entities)一个物业@Database注释，房间在数据库实体创建一个数据库表。 默认情况下，客房创造了该公司在实体定义的每个字段的列。如果一个实体，你不想坚持字段，可以标注其使用@Ignore，如下面的代码片段：1234567891011@Entityclass User &#123; @PrimaryKey public int id; public String firstName; public String lastName; @Ignore Bitmap picture;&#125; 要坚持一个领域，房间必须能够访问它。你可以做一个业界人士，或者你可以提供一个setter和getter它。如果您使用的setter和getter方法，牢记根据房间Java组件约定，他们是。 主键(Primary key)每个实体必须定义至少1字段作为主键。即使只有1场，你仍然需要注释字段的@PrimaryKey注释。另外，如果你想室自动分配ID的实体，您可以设置@PrimaryKey的autoGenerate)属性。如果实体有一个复合主键，你可以使用primaryKeys)该财产@Entity的注释，如下面的代码片段：12345678@Entity(primaryKeys = &#123;\"firstName\", \"lastName\"&#125;)class User &#123; public String firstName; public String lastName; @Ignore Bitmap picture;&#125; 默认情况下，房使用类名作为数据库表名。如果你想表有不同的名称，设置tableName)的财产@Entity注释，如下面的代码片段：1234@Entity(tableName = \"users\")class User &#123; ...&#125; &lt;b&gt;注意：&lt;/b&gt;在SQLite表名不区分大小写。 类似于tableName)property，客房使用的字段名在数据库中的列名。如果你想要一个列有不同的名称，添加@ColumnInfo注释字段，如下面的代码片段：1234567891011121314@Entity(tableName = \"users\")class User &#123; @PrimaryKey public int id; @ColumnInfo(name = \"first_name\") public String firstName; @ColumnInfo(name = \"last_name\") public String lastName; @Ignore Bitmap picture;&#125; 指标和唯一性(Indices and uniqueness)根据您如何访问这些数据，你可能要索引某些领域在数据库中加快查询速度。要指数添加到实体，包括indices) 在property的 @Entity 注解，列出要在索引或复合索引中的列的名称。下面的代码片段演示了这种注释过程：1234567891011121314@Entity(indices = &#123;@Index(\"name\"), @Index(\"last_name\", \"address\")&#125;)class User &#123; @PrimaryKey public int id; public String firstName; public String address; @ColumnInfo(name = \"last_name\") public String lastName; @Ignore Bitmap picture;&#125; 有时候，某些字段或字段组在数据库中必须是唯一的。您可以通过设置执行这种独特属性unique) 的财产@Index 注解true。下面的代码示例防止表从具有包含相同的组的值的两行firstName 和 lastName列： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114Entity(indices = &#123;@Index(value = &#123;\"first_name\", \"last_name\"&#125;, unique = true)&#125;)class User &#123; @PrimaryKey public int id; @ColumnInfo(name = \"first_name\") public String firstName; @ColumnInfo(name = \"last_name\") public String lastName; @Ignore Bitmap picture;&#125;```` #### &lt;b&gt;关系(Relationships)&lt;/b&gt;由于SQLite是一个关系型数据库，你可以指定对象之间的关系。尽管大多数ORM库允许实体对象之间互相引用，房间明确禁止这一点。有关详细信息，请参阅[附录：实体之间没有对象引用](#附录：实体之间没有对象引用-Addendum-No-object-references-between-entities)。即使你不能使用直接关系，房间仍然可以让你的实体之间定义外键约束。举例来说，如果有一个名为另一个实体Book，你可以定义它关系到User使用实体 [@ForeignKey](https://developer.android.google.cn/reference/android/arch/persistence/room/ForeignKey.html) 注释，如下面的代码片段：````Java@Entity(foreignKeys = @ForeignKey(entity = User.class, parentColumns = \"id\", childColumns = \"user_id\"))class Book &#123; @PrimaryKey public int bookId; public String title; @ColumnInfo(name = \"user_id\") public int userId;&#125; ```` 外键是非常强大的，因为它们允许你指定的时候引用的实体被更新时发生的情况。举例来说，你可以告诉SQLite的删除所有书籍的用户，如果对应的实例User是由包括已删除onDelete=CASCADE 的 @ForeignKey 注解。 &gt;&lt;b&gt;注：&lt;/b&gt;SQLite的处理 @Insert(OnConflict=REPLACE) 为一组REMOVE和REPLACE操作，而不是一个单一的UPDATE 操作。替换冲突的价值观的这种方法可能会影响你的外键约束。有关详细信息，请参阅SQLite的文档的 ON_CONFLICT条款。#### 嵌套对象(Nested objects)有时候，你想表达作为一个整体的实体或普通的旧式Java对象（POJO）中在你的数据库逻辑，即使对象包含多个字段。在这些情况下，您可以使用 @Embedded 注解来表示一个对象，你想分解成一个表内的子域。然后，您可以查询嵌入式领域就像你对其他各列。例如，我们的User类可以包括类型的字段Address，它代表的命名字段组成street，city，state，和 postCode。单独地存储在表中的组成的列，包括一个 Address在该领域User被注释与类 @Embedded，如显示在下面的代码片断：````Javaclass Address &#123; public String street; public String state; public String city; @ColumnInfo(name = \"post_code\") public int postCode;&#125;@Entityclass User &#123; @PrimaryKey public int id; public String firstName; @Embedded public Address address;&#125;```` 表示该表User对象则包含以下名称的列：id，firstName，street，state，city，和post_code。 &gt;&lt;b&gt;注：&lt;/b&gt;嵌入式领域也可以包括其他嵌入式领域。 如果实体具有相同类型的多个嵌入式领域，你可以保持每列设置的独特 prefix 属性。房间然后将所提供的价值，在嵌入式对象中的每个列名的开头。### &lt;b&gt;数据访问对象（Data Access Objects (DAOs）&lt;/b&gt;在房间的主要成分是Dao类。DAO的抽象访问数据库的清洁方式。 &gt;&lt;b&gt;注意：&lt;/b&gt;房间不允许在主线程访问数据库，除非你叫 allowMainThreadQueries() 的建设者，因为它可能会锁定该UI的时间过长。 异步查询（返回的查询LiveData或RxJava Flowable）不受此规则豁免，因为他们需要异步时在后台线程运行查询。#### 为了方便方法(Methods for convenience)有多种方便的查询，你可以代表使用DAO类。这份文件包括几个常见的例子。&lt;font size=4.5&gt; &lt;b&gt;Insert&lt;/b&gt;&lt;/font&gt;当你创建一个DAO方法及标注它 @Insert，间产生插入所有参数到一个单一的交易数据库的实现。下面的代码片段显示了几个例子查询：````Java@Daopublic interface MyDao &#123; @Insert(onConflict = OnConflictStrategy.REPLACE) public void insertUsers(User... users); @Insert public void insertBothUsers(User user1, User user2); @Insert public void insertUsersAndFriends(User user, List&lt;User&gt; friends);&#125; 如果@Insert 方法仅接收1个参数，它可以返回long，这是新 rowId插入的项。如果参数是一个数组或集合，它应该返回long[]或List代替。 有关详细信息，请参阅参考文档 @Insert注释，还有的ROWID表SQLite的文档。 &gt;Update Update是，更新作为参数给出一个实体的集合，在数据库中的便捷方法。它采用的是针对每个实体的主键匹配的查询。下面的代码片段演示了如何定义这个方法：12345@Daopublic interface MyDao &#123; @Update public void updateUsers(User... users);&#125; 虽然通常没有必要，你可以有这个方法返回一个int值，而不是，这表明在数据库中更新的行数。 Delete Delete是，删除作为参数给出一个实体的集合，从数据库中的便捷方法。它使用主键查找实体进行删除。下面的代码片段演示了如何定义这个方法：12345@Daopublic interface MyDao &#123; @Delete public void deleteUsers(User... users);&#125; 虽然通常没有必要，你可以有这个方法返回一个int值，而不是，说明从数据库中删除的行数。 使用方法@Query(Methods using @Query)@Query在DAO类中使用的主要的注释。它可以让你执行一个数据库上的读/写操作。每个 @Query方法在编译时进行验证，所以如果有与查询问题，发生的不是一个运行时故障编译错误。 房间也验证查询，例如，如果在返回的对象中字段的名称并不在查询响应匹配相应的列名，房间提醒您通过以下两种方式之一的返回值： 它给出了一个警告，如果只有一些字段名相匹配。如果没有字段名匹配它给出了一个错误。 简单的查询(Simple queries)12345@Daopublic interface MyDao &#123; @Query(\"SELECT * FROM user\") public User[] loadAllUsers();&#125;这是加载所有用户一个非常简单的查询。在编译的时候，房间知道它查询在用户表中的所有列。如果查询包含语法错误，或者如果用户表不存在于数据库中，室显示与为您的应用程序编译相应的消息的错误。传递参数到查询(Passing parameters into the query) 大多数时候，你需要的参数传递到查询进行过滤操作，比如只显示谁比了一定的年龄老用户。为了完成这个任务，使用方法参数在你的房间注释，如下面的代码片段：12345@Daopublic interface MyDao &#123; @Query(\"SELECT * FROM user WHERE age &gt; :minAge\") public User[] loadAllUsersOlderThan(int minAge);&#125; 当该查询是在编译时处理室的匹配:minAge与绑定参数minAge方法参数。执行室使用的参数名称匹配。如果不匹配，为你的应用程序编译时发生错误。 还可以将多个参数传递或多次引用它们中的查询，如图下面的代码片断： 123456789@Daopublic interface MyDao &#123; @Query(\"SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge\") public User[] loadAllUsersBetweenAges(int minAge, int maxAge); @Query(\"SELECT * FROM user WHERE first_name LIKE :search \" + \"OR last_name LIKE :search\") public List&lt;User&gt; findUserWithName(String search);&#125; 返回列的子集(Returning subsets of columns) 在大多数情况下，你需要获得唯一的一个实体的几个领域。例如，您的用户界面可能会只显示一个用户的名字和姓氏，而不是对用户的每一个细节。通过仅提取出现在你的应用程序的UI中的列，为您节省宝贵的资源，和您的查询更迅速地完成。 房间可以让你回到您查询的任何Java对象，只要设定结果列都可以映射到返回的对象。例如，您可以创建以下POJO来抓取用户的姓氏和名字：1234567public class NameTuple &#123; @ColumnInfo(name=\"first_name\") public String firstName; @ColumnInfo(name=\"last_name\") public String lastName;&#125; 现在，你可以在你的查询方法使用POJO：12345@Daopublic interface MyDao &#123; @Query(\"SELECT first_name, last_name FROM user\") public List&lt;NameTuple&gt; loadFullName();&#125; 了解，查询的返回值first_name和 last_name列，这些值可以被映射到的领域 NameTuple类。因此，Room可以生成正确的代码。如果查询返回太多的列，或者说不会在存在的列NameTuple 级，间显示警告。 注意：这些POJO的也可以使用 @Embedded 注解。 传递的参数集合(Passing a collection of arguments)M 一些您的查询可能需要你的参数变量数传，用不知道，直到运行参数的确切人数。例如，您可能要检索从区域子集所有用户的信息。当一个参数代表收集室理解并自动根据所提供的参数的数量在运行时扩展它。12345@Daopublic interface MyDao &#123; @Query(\"SELECT first_name, last_name FROM user WHERE region IN (:regions)\") public List&lt;NameTuple&gt; loadUsersFromRegions(List&lt;String&gt; regions);&#125; 可观察的查询(Observable queries) 当执行查询，你经常会想你的应用程序的用户界面自动更新当数据变化。要做到这一点，使用类型的返回值LiveData的查询方法的说明。房间生成所有必要的代码更新 LiveData时更新数据库。12345@Daopublic interface MyDao &#123; @Query(\"SELECT first_name, last_name FROM user WHERE region IN (:regions)\") public LiveData&lt;List&lt;User&gt;&gt; loadUsersFromRegionsSync(List&lt;String&gt; regions);&#125; 注：由于1.0版本的，房间使用查询访问的表的列表，以决定是否更新LiveData对象。 RxJava 房间还可以返回RxJava2 Publisher并Flowable从您定义的查询对象。要使用此功能，添加 android.arch.persistence.room:rxjava2从房间组神器到您的构建摇篮依赖。然后，您可以返回的RxJava2定义的类型对象，如下面的代码片段：12345@Daopublic interface MyDao &#123; @Query(\"SELECT * from user where id = :id LIMIT 1\") public Flowable&lt;User&gt; loadUserById(int id);&#125; 直接光标访问(Direct cursor access) 如果您的应用程序的逻辑要求返回行的直接访问，可以返回一个Cursor从你的查询对象，如下面的代码片段：12345@Daopublic interface MyDao &#123; @Query(\"SELECT * FROM user WHERE age &gt; :minAge LIMIT 5\") public Cursor loadRawUsersOlderThan(int minAge);&#125; 注意：这是非常泄气用光标API的工作，因为它不能保证是否存在行或什么值的行包含.使用此功能， 只有当你已经有预期的光标代码，并且你不能轻易重构。 查询多个表(Querying multiple tables) 一些您的查询可能需要访问多个表来计算结果。房间让你写任何查询，所以你也可以加入表。此外，如果响应是可观察到的数据类型，如Flowable或 LiveData室手表在查询为无效引用的所有表。 下面的代码片段展示了如何执行表连接，以巩固含有谁是图书借阅和用户表之间的信息包含有关书籍目前贷款数据表：12345678@Daopublic interface MyDao &#123; @Query(\"SELECT * FROM book \" + \"INNER JOIN loan ON loan.book_id = book.id \" + \"INNER JOIN user ON user.id = loan.user_id \" + \"WHERE user.name LIKE :userName\") public List&lt;Book&gt; findBooksBorrowedByNameSync(String userName);&#125; 您也可以从这些查询返回的POJO。例如，你可以写加载一个用户和他们的宠物的名字，如下所示的查询：1234567891011121314@Daopublic interface MyDao &#123; @Query(\"SELECT user.name AS userName, pet.name AS petName \" + \"FROM user, pet \" + \"WHERE user.id = pet.user_id\") public LiveData&lt;List&lt;UserPet&gt;&gt; loadUserAndPetNames(); // You can also define this class in a separate file, as long as you add the // \"public\" access modifier. static class UserPet &#123; public String userName; public String petName; &#125;&#125; 使用类型转换器(Using type converters)客房提供了原语及其盒装替代内置支持。不过，有时你使用自定义的数据类型，它的值，你想在数据库存储在单个列。要添加这种自定义类型的支持，你提供 TypeConverter，其自定义类转换，并从一个已知类型的房间能坚持。 例如，如果我们想坚持的情况下Date，我们可以写出下面的 TypeConverter 等效Unix时间戳存储在数据库中：1234567891011public class Converters &#123; @TypeConverter public static Date fromTimestamp(Long value) &#123; return value == null ? null : new Date(value); &#125; @TypeConverter public static Long dateToTimestamp(Date date) &#123; return date == null ? null : date.getTime(); &#125;&#125; 前面的例子中定义了两个函数，一个一个转换Date对象到Long对象和另一个执行逆变换，从Long到Date。由于房间已经知道如何坚持Long的对象，就可以使用此转换器持续类型的值 Date。 接下来，您将添加 @TypeConverters 注释到AppDatabase类，这样可以房间使用你在每个实体和DAO定义的转换器AppDatabase： AppDatabase.java123456@Database(entities = &#123;User.java&#125;, version = 1)@TypeConverters(&#123;Converter.class&#125;)public abstract class AppDatabase extends RoomDatabase &#123; public abstract UserDao userDao();&#125; 使用这些转换器，就可以使用您的自定义类型的其他查询，就像你会使用原始的类型，如下面的代码片段： User.java123456789101112@Entitypublic class User &#123; ... private Date birthday;&#125;UserDao.java@Daopublic interface UserDao &#123; ... @Query(\"SELECT * FROM user WHERE birthday BETWEEN :from AND :to\") List&lt;User&gt; findUsersBornBetweenDates(Date from, Date to);&#125; 您还可以限制 @TypeConverters 范围不同，包括个人实体的DAO和DAO方法。有关详细信息，请参阅参考文档 @TypeConverters 注释。 数据库迁移(Database migration)正如你在你的应用程序添加和更改的功能，你需要修改你的实体类，以反映这些变化。当用户更新到您的应用程序的最新版本，你不希望他们失去所有的现有数据，特别是如果你不能从远程服务器恢复数据。 房间让你写 Migration 的类以这种方式保存用户数据。每一 Migration 类指定startVersion和endVersion。在运行时，运行室每个 Migration 类的 migrate() 方法，用正确的顺序将数据库迁移到更高版本。 注意：如果不提供必要的迁移，重建室数据库，而不是，这意味着你将失去所有的数据在数据库中。 123456789101112131415161718Room.databaseBuilder(getApplicationContext(), MyDb.class, \"database-name\") .addMigrations(MIGRATION_1_2, MIGRATION_2_3).build();static final Migration MIGRATION_1_2 = new Migration(1, 2) &#123; @Override public void migrate(SupportSQLiteDatabase database) &#123; database.execSQL(\"CREATE TABLE `Fruit` (`id` INTEGER, \" + \"`name` TEXT, PRIMARY KEY(`id`))\"); &#125;&#125;;static final Migration MIGRATION_2_3 = new Migration(2, 3) &#123; @Override public void migrate(SupportSQLiteDatabase database) &#123; database.execSQL(\"ALTER TABLE Book \" + \" ADD COLUMN pub_year INTEGER\"); &#125;&#125;; 注意：为了使您的迁移逻辑功能如预期，而不是使用引用代表查询常量全查询。 迁移过程完成后，房验证模式，以确保正确地发生的迁移。如果房间发现一个问题，它抛出一个包含不匹配的信息异常。 测试迁移(Testing migrations)迁移是不平凡的编写，以及未能妥善他们写可能导致您的应用程序崩溃循环。为了保护您的应用程序的稳定性，你应该先测试你的迁移。客房提供了一个测试 Maven构件，以协助这个测试过程。然而，对于这个神器的工作，你需要导出数据库的模式。 导出模式(Exporting schemas)在编译时，房间出口你的数据库的架构信息成JSON文件。要导出模式，将room.schemaLocation在您的注解处理器特性build.gradle文件，如下面的代码片段： 的build.gradle123456789101112android &#123; ... defaultConfig &#123; ... javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [\"room.schemaLocation\": \"$projectDir/schemas\".toString()] &#125; &#125; &#125;&#125; 你应该存储导出文件，JSON，这代表你的数据库的架构历史在你的版本控制系统，因为它允许室来创建用于测试的旧版本的数据库。 为了测试这些迁移，添加android.arch.persistence.room:testing 从房间Maven构件到测试的依赖，并添加架构位置作为资产的文件夹，如下面的代码片段： 的build.gradle123456android &#123; ... sourceSets &#123; androidTest.assets.srcDirs += files(\"$projectDir/schemas\".toString()) &#125;&#125; 测试包提供了一个 MigrationTestHelper 类，它可以读取这些架构文件。这也是一个Junit4 TestRule 类，所以它可以管理创建的数据库。 样品迁移测试显示在下面的代码段：1234567891011121314151617181920212223242526272829303132@RunWith(AndroidJUnit4.class)public class MigrationTest &#123; private static final String TEST_DB = \"migration-test\"; @Rule public MigrationTestHelper helper; public MigrationTest() &#123; helper = new MigrationTestHelper(InstrumentationRegistry.getContext(), MigrationDb.class.getCanonicalName(), new FrameworkSQLiteOpenHelperFactory()); &#125; @Test public void migrate1To2() throws IOException &#123; SupportSQLiteDatabase db = helper.createDatabase(TEST_DB, 1); // db has schema version 1. insert some data using SQL queries. // You cannot use DAO classes because they expect the latest schema. db.execSQL(...); // Prepare for the next version. db.close(); // Re-open the database with version 2 and provide // MIGRATION_1_2 as the migration process. db = helper.runMigrationsAndValidate(TEST_DB, 2, true, MIGRATION_1_2); // MigrationTestHelper automatically verifies the schema changes, // but you need to validate that the data was migrated properly. &#125;&#125; 测试你的数据库(Testing your database)当运行你的应用程序的测试，你不应该需要创建一个完整的数据库，如果你不是测试数据库本身。房间可以让你轻松地嘲笑你的测试数据访问层。这个过程是可能的，因为你的DAO不会泄露你的数据库的任何细节。在测试您的应用程序的其余部分，你应该创建你的DAO类的模拟或假的实例。 有2种方式来测试你的数据库： 在您的主机开发机。在Android设备上。 测试你的主机上(Testing on your host machine)客房使用SQLite的支持库，它提供匹配在Android框架类，接口。这种支持允许你通过支持库的自定义实现，以测试你的数据库查询。 尽管此设置可以让你的测试非常快速地运行，不建议这样做，因为你的设备和您的用户运行的SQLite版本的设备，可能不符合你的主机上的版本。 测试在Android设备上(Testing on an Android device)测试你的数据库实现建议的方法是编写一个Android设备上运行的JUnit测试。因为这些测试并不需要创建活动，他们应该是快于你的UI测试执行。 当设置你的测试，您应该创建一个内存版本的数据库，使您的测试更密闭，如在下面的例子：1234567891011121314151617181920212223242526@RunWith(AndroidJUnit4.class)public class SimpleEntityReadWriteTest &#123; private UserDao mUserDao; private TestDatabase mDb; @Before public void createDb() &#123; Context context = InstrumentationRegistry.getTargetContext(); mDb = Room.inMemoryDatabaseBuilder(context, TestDatabase.class).build(); mUserDao = mDb.getUserDao(); &#125; @After public void closeDb() throws IOException &#123; mDb.close(); &#125; @Test public void writeUserAndReadInList() throws Exception &#123; User user = TestUtil.createUser(3); user.setName(\"george\"); mUserDao.insert(user); List&lt;User&gt; byName = mUserDao.findUsersByName(\"george\"); assertThat(byName.get(0), equalTo(user)); &#125;&#125; 有关测试数据库迁移的详细信息，请参阅迁移测试。 附录：实体之间没有对象引用(Addendum: No object references between entities)从数据库到各自的对象模型的映射关系是一种常见的做法，工作得非常好，在服务器端它是高性能的，因为它们可以访问懒洋洋地加载领域。 然而，在客户端，延迟加载，因为它很可能在UI线程上发生，并查询在UI线程的磁盘信息造成显著的性能问题是不可行的。在UI线程具有约16毫秒来计算和绘制活动的最新布局，这样即使查询只需要5毫秒，它仍然可能是您的应用程序将运行的时间来绘制框架，造成明显的JANK。更糟糕的是，查询可能需要更多的时间来完成，如果有并行运行一个单独的事务，或者如果该设备是忙于其他磁盘繁重的任务。如果你不使用延迟加载，但是，应用程序获取更多的数据比实际需要，建立内存消耗问题。 奥姆斯通常会离开这个决定给开发人员，使他们能够做什么是最适合他们的应用程序的使用情况。不幸的是，开发者通常最终会分享他们的应用程序和UI之间的模式。随着时间的用户界面的变化，出现问题难以预料和调试。 例如，采取加载的列表的UI Book对象，每个书具有Author对象。你可能一开始设计自己的查询中使用延迟加载这样的情况下，Book使用getAuthor()方法返回的作者。在第一次调用getAuthor()调用查询数据库。一段时间后，你意识到你需要在你的应用程序的用户界面，显示作者的名字，也是如此。您可以添加的方法调用很轻松了，因为显示在下面的代码片段：1authorNameTextView.setText(user.getAuthor().getName()); 然而，这种看似无辜的变化导致Author主线程上进行查询的表。 如果你急切地询问作者的信息，就很难改变，如果您在不再需要数据加载的数据，例如当你的应用程序的用户界面不再需要显示有关特定信息的情况Author。因此，您的应用程序必须继续加载数据，它不再显示。如果这种情况甚至更糟Author类引用另一个表，如与 getBooks()方法。 由于这些原因，Room不允许实体类之间的对象引用。相反，你必须明确地要求你的应用程序需要的数据。","categories":[],"tags":[{"name":"Room Persistence","slug":"Room-Persistence","permalink":"http://yangchaojiang.cn/tags/Room-Persistence/"}]},{"title":"Architecture_Components  LiveData 学习","slug":"livedata-blog","date":"2017-06-05T01:00:26.000Z","updated":"2017-06-06T10:59:14.000Z","comments":true,"path":"2017/06/05/livedata-blog/","link":"","permalink":"http://yangchaojiang.cn/2017/06/05/livedata-blog/","excerpt":"LiveDataLiveData是数据保持器类的值和运算。不像常规可见，LiveData该生命周期的应用程序组件，使得遵守者可以指定Lifecycle它在哪应注意观察。 注：实时为您导入Android项目添加组件你的项目。","text":"LiveDataLiveData是数据保持器类的值和运算。不像常规可见，LiveData该生命周期的应用程序组件，使得遵守者可以指定Lifecycle它在哪应注意观察。 注：实时为您导入Android项目添加组件你的项目。LiveData认为遵守者在活跃状态中如果遵守者’sLifecycle是的STARTED作业代表RESUMED状态。12345678910111213141516171819202122232425public class LocationLiveData extends LiveData&lt;Location&gt; &#123; private LocationManager locationManager; private SimpleLocationListener listener = new SimpleLocationListener() &#123; @Override public void onLocationChanged(Location location) &#123; setValue(location); &#125; &#125;; public LocationLiveData(Context context) &#123; locationManager = (LocationManager) context.getSystemService( Context.LOCATI+-ON_SERVICE); &#125; @Override protected void onActive() &#123; locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, listener); &#125; @Override protected void onInactive() &#123; locationManager.removeUpdates(listener); &#125;&#125; 有三个重要部分中的这种实现Location： onActive() 当该方法被称为 LiveData具有有源观察者。这意味着我们需要开始观测从设备的位置更新。 onInactive() 当这种方法被称为 LiveData没有任何积极的观察员。由于没有观察们监听，也没有理由保持连接到LocationManager服务。这很重要，因为保持连接会消耗显著电池电量没有任何好处。 setValue() 调用此方法将更新后的值 LiveData与实例观察员活动通知。我们可以用新的LocationLiveData() 如下所示：12345678910111213public class MyFragment extends LifecycleFragment &#123; public void onActivityCreated (Bundle savedInstanceState) &#123; LiveData&lt;Location&gt; myLocationListener = ...; Util.checkUserStatus(result -&gt; &#123; if (result) &#123; myLocationListener.addObserver(this, location -&gt; &#123; // update UI &#125;); &#125; &#125;); &#125;&#125; &#125;&#125; 请注意，该addObserver()方法通过了 LifecycleOwner作为第一个参数。这样做就表示该观察者应该绑定到 Lifecycle，意思是： 如果Lifecycle处于激活状态不是（STARTED或RESUMED），观察者不叫即使该值的变化。 如果Lifecycle被破坏，观察者被自动删除。 这事实上LiveData是生命周期感知为我们提供了新的契机：我们可以在多个活动，片段等之间的分享。为了保持我们的例子简单，我们可以按照如下使单：12345678910111213141516171819202122232425262728293031323334public class LocationLiveData extends LiveData&lt;Location&gt; &#123; private static LocationLiveData sInstance; private LocationManager locationManager; @MainThread public static LocationLiveData get(Context context) &#123; if (sInstance == null) &#123; sInstance = new LocationLiveData(context.getApplicationContext()); &#125; return sInstance; &#125; private SimpleLocationListener listener = new SimpleLocationListener() &#123; @Override public void onLocationChanged(Location location) &#123; setValue(location); &#125; &#125;; private LocationLiveData(Context context) &#123; locationManager = (LocationManager) context.getSystemService( Context.LOCATION_SERVICE); &#125; @Override protected void onActive() &#123; locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, listener); &#125; @Override protected void onInactive() &#123; locationManager.removeUpdates(listener); &#125;&#125; 现在片段按如下方式使用它：1234567891011public class MyFragment extends LifecycleFragment &#123; public void onActivityCreated (Bundle savedInstanceState) &#123; Util.checkUserStatus(result -&gt; &#123; if (result) &#123; LocationLiveData.get(getActivity()).observe(this, location -&gt; &#123; // update UI &#125;); &#125; &#125;); &#125;&#125; 可能有多个片段和活动正在观察我们的 MyLocationListener实例，并 LiveData优雅地管理它们，使其连接到系统服务只有当他们中任何一个可见的（即活动）。 本LiveData类提供了以下优点： 没有内存泄漏:由于Observers的束缚自己的Lifecycle对象，当他们被自动清除 Lifecycle被破坏。 没有崩溃，由于停止活动:如果Observer的 Lifecycle是无效的（就像在后面堆栈的活动），他们将不会收到更改事件。 始终保持最新数据：如果 Lifecycle再次开始（如活动可以追溯到从后面堆启动的状态），它接收到的最新位置数据（如果没有的话）。 适当的配置变化：如果一个活动或片段由于重新创建到的配置改变（如设备旋转），它立即接收的最后一个可用Location的数据。 资源共享：现在我们能保持的单个实例 MyLocationListener，连接到系统服务只有一次，并适当支持的应用程序的所有观察员。 没有更多的人工生命周期处理：正如你可能已经注意到，我们的片段只是当它想，不担心被停止或启动停止后观察观察数据。LiveData 由于片段提供了自动管理所有的这 Lifecycle一边观察。 LiveData的转换有时候，你可能希望更改 LiveData其派遣到观察员前值，或者您可能需要返回不同的 LiveData基础上另外一个的值实例。 生命周期包提供了一个 Transformations，包含对这些操作的辅助方法 Transformations.map()‘) 在应用函数 LiveData值，和下游传播的结果。 1234LiveData&lt;User&gt; userLiveData = ...;LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123; user.name + \" \" + user.lastName&#125;); Transformations.switchMap()‘) 类似于map()‘),应用一个函数的值，并解开和下游调度的结果。传递给函数 switchMap()‘)必须返回 Lifecycle。123456private LiveData&lt;User&gt; getUser(String id) &#123; ...;&#125;LiveData&lt;String&gt; userId = ...;LiveData&lt;User&gt; user = Transformations.switchMap(userId, id -&gt; getUser(id) ); 使用这些转换允许结转观察者 Lifecycle对面，使得这些转换没有被计算，除非一个观察者观察返回链路信息LiveData转换的这种懒惰的计算特性允许隐传下来的生命周期相关的行为，而不增加显式调用或依赖关系每当你认为你需要 Lifecycle内部的对象ViewModel一、转化是可能的解决方案。 例如，我们假设一个UI，用户将在地址和他们的邮政编码的地址。幼稚的LiveData对于这种UI可以像这样：1234567891011class MyViewModel extends ViewModel &#123; private final PostalCodeRepository repository; public MyViewModel(PostalCodeRepository repository) &#123; this.repository = repository; &#125; private LiveData&lt;String&gt; getPostalCode(String address) &#123; // DON'T DO THIS return repository.getPostCode(address); &#125;&#125; 如果是这样的实现中，UI将需要从之前的注销LiveData和重新登记，在每个时间实例新呼叫他们getPostalCode()。 此外，如果所述UI是重新创建，则它触发另一个调用repository.getPostCode()代替使用在先前呼叫的结果。 代替使用该方法时，可以实现如邮政编码信息一种变换地址的输入：12345678910111213141516class MyViewModel extends ViewModel &#123; private final PostalCodeRepository repository; private final MutableLiveData&lt;String&gt; addressInput = new MutableLiveData(); public final LiveData&lt;String&gt; postalCode = Transformations.switchMap(addressInput, (address) -&gt; &#123; return repository.getPostCode(address); &#125;); public MyViewModel(PostalCodeRepository repository) &#123; this.repository = repository &#125; private void setInput(String address) &#123; addressInput.setValue(address); &#125;&#125; 请注意，我们还送了postalCode场 public final，因为它永远不会改变。 它被定义为所述的变换addressInput，使得当addressInput变化，如果存在活动的观察者， repository.getPostCode()被调用。如果没有活动的观察员出席了通话的时间，也不执行计算，直到观察员加入。 这种机制允许应用水平较低，以创建 LiveData即是按需计算懒洋洋的对象。LiveData可以很容易地获得它们，在它们上面定义转换规则。 创建新转换（Creating new transformations）有迹象表明，可能在你的应用程序非常有用十几个不同的特定的转换，但默认情况下不提供。为了实现自己的转型， 你可以使用 MediatorLiveData 类，它是专门创建适当听取其他LiveData实例，通过它们发出的处理事件。MediatorLiveData 需要关心到正确地传播其活动/非活动状态到所述源 LiveData您可以检查执行 Transformations的细节。","categories":[],"tags":[{"name":"Architecture_Components","slug":"Architecture-Components","permalink":"http://yangchaojiang.cn/tags/Architecture-Components/"},{"name":"LiveData","slug":"LiveData","permalink":"http://yangchaojiang.cn/tags/LiveData/"}]},{"title":"google 新出开发应用架构 Architecture Components ( Lifecycles LiveDatra Room) 组件架构，目前公开测试阶段","slug":"architecture","date":"2017-06-04T04:20:18.000Z","updated":"2017-06-06T10:59:02.000Z","comments":true,"path":"2017/06/04/architecture/","link":"","permalink":"http://yangchaojiang.cn/2017/06/04/architecture/","excerpt":"一.依赖 库文件 体系结构组件都可以从谷歌的Maven仓库。要使用它们，请按照下列步骤操作： 添加谷歌Maven仓库Android Studio中项目默认不配置访问该存储库。 将它添加到你的项目中，打开build.gradle文件的项目（不是那些对你的应用程序或模块），并添加突出显示的行，如下图所示：","text":"一.依赖 库文件 体系结构组件都可以从谷歌的Maven仓库。要使用它们，请按照下列步骤操作： 添加谷歌Maven仓库Android Studio中项目默认不配置访问该存储库。 将它添加到你的项目中，打开build.gradle文件的项目（不是那些对你的应用程序或模块），并添加突出显示的行，如下图所示：123456allprojects &#123; repositories&#123; jcenter （） maven &#123; URL &apos;https://maven.google.com&apos; &#125; &#125;&#125; 加合架构组件打开build.gradle文件的应用程序或模块，并添加你需要的依赖关系的假象： 对于生命周期，LiveData和视图模型，添加：12345compile &quot;android.arch.lifecycle:runtime:1.0.2-alpha1&quot;compile &quot;android.arch.lifecycle:extensions:1.0.2-alpha1&quot;annotationProcessor &quot;android.arch.lifecycle:compiler:1.0.2-alpha1&quot; For Room，地址：123compile &quot;android.arch.persistence.room:runtime:1.0.2-alpha1&quot;annotationProcessor &quot;android.arch.persistence.room:compiler:1.0.2-alpha1&quot; For testing Room migrations,，添加：1testCompile &quot;android.arch.persistence.room:testing:1.0.2-alpha1&quot; 对于RxJava支持，增加：1compile &quot;android.arch.persistence.room:rxjava2:1.0.2-alpha1&quot;","categories":[],"tags":[{"name":"Architecture Components","slug":"Architecture-Components","permalink":"http://yangchaojiang.cn/tags/Architecture-Components/"}]},{"title":"我的第一个博客","slug":"my-first-blog","date":"2017-06-04T02:28:48.000Z","updated":"2017-06-06T10:44:34.000Z","comments":true,"path":"2017/06/04/my-first-blog/","link":"","permalink":"http://yangchaojiang.cn/2017/06/04/my-first-blog/","excerpt":"","text":"","categories":[],"tags":[]}]}